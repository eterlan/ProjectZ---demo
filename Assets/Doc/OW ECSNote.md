# Note

```C#
Timer -> 对于复杂度不高的简单应用，在不同系统中的一些repeatness是可行的，过度的抽象反而会增加复杂度和降低可读性。况且在不同地方的应用也不可能是完全repeat的，判断所使用的变量不常是单个变量

一些重复的代码可以放进Util中。

对于，不用过多担心以后改代码应该如何降低修改成本的问题。OOP添加函数麻烦（多个继承对象都要改），FP添加新的结构体变量麻烦（函数要改），而ECS的system属于FP，因此因Component改动而不得不动系统是很正常的，不要因此增加代码复杂度。（待商榷：DecisionSystem，不过话说回来，DS的复杂度也是因为没有分层考虑状态机，全部行为塞一起是肯定不行的）//@TODO 考虑多层

冰山Component？意思是抛开最上层易于理解与书写的抽象外，内部状态不暴露出来，只把结果暴露给ECS高层。e.g.演讲中用的例子是他们的之前的物理系统，换到Unity来说就是之前的MonoBehaviour。

（建议换掉hybrid ECS的说法，因为本质是让ECS只关注结果，杂交让人听起来emm）

sibling ？Unity ECS有可行的实现方式吗？

不同的对象视角中的一个状态对他们来说有不同的意义，这是为什么不作为OOP的原因。他们不是对象，只是因"人”而异的一些状态而已。

对于较为复杂的系统，可以把具体实现放到函数中，定式中只填写高层抽象的逻辑判断。//@TODO 考虑拆解成函数

单例Component？全局获取的单例状态？Unity ECS有可行的实现方式吗？

推迟技术的重要性：1.减少真正调用根函数的次数 2.运算放进多线程，批量计算
```

WorkFlow

考虑大致的系统 考虑哪些用Unity哪些用ECS 如何交互 UI有哪些信息

针对一个系统填写具体需求

根据一个需求写较细致的TODO

复杂的TDD 简单的直接做然后测试

​	需要什么，处理什么，怎么得到结果  

反过来考虑代码优化，比如合并到Util，减少函数调用点，系统拆解耦合，只读



// New API manager.SetEnabled?





